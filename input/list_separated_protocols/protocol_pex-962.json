[
    "\n<p><strong>Procedure </strong></p><p><br></p><p><strong>1.&nbsp;&nbsp;&nbsp;<u>Pre-processing</u></strong></p><p><strong><u>&nbsp;</u></strong></p><p><strong>Conversion</strong>: Raw sequencing data (Illumina sequencer’s base call files (BCLs) was converted to fastq files using the Illumina <em>bcl2fastq</em> program&nbsp;</p><p><strong>&nbsp;</strong></p><p><strong>Trimming:</strong> The reads from Fastq files were trimmed to remove poly A tail and G overhang, primer dimers and the 5 base umi was extracted. umi_homopolymer.py is downloaded from<a href=\"https://github.com/jwfoley/3SEQtools\" rel=\"noopener noreferrer\" target=\"_blank\"> https://github.com/jwfoley/3SEQtools</a></p><p><em>&nbsp;</em></p><p><strong>Aligning:</strong> The trimmed reads were aligned, using STAR-2.7.2a (Dobin et al. 2013) to the Sus scrofa reference genome sequence version Sus_scrofa.Sscrofa11.1.fasta, available in the Ensembl database. &nbsp;Sus_scrofa.Sscrofa11.1.95.gtf was used as a reference transcriptome. The STAR parameters we used specific to our dataset were --outFilterMismatchNmax 999 (for mismatch) , --outFilterMultimapNmax 1&nbsp;(to take care of the multi-mapping) and clip3pAdapterSeq AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA (clipping the adapter reads at 3` end)<em>. </em>&nbsp;&nbsp;Below are the steps.</p><p><br></p><p>●&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Download the latest version of STAR aligner software</p><p>●&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Download the reference fasta file from Ensembl database</p><p>●&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Download the reference annotation file from Ensembl database</p><p>●&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create the genome index file using the command</p><p><em>STAR --runThreadN 4 --runMode genomeGenerate --genomeDir path --&nbsp;genomeFastaFiles&nbsp;&nbsp;&nbsp;&nbsp;Sus_scrofa.Sscrofa11.1.fasta --sjdbGTFfile Sus_scrofa.Sscrofa11.1.95.gtf&nbsp;--sjdbOverhang 100</em></p><p><br></p><p><strong>Merging sam files: </strong>Aligned files from reads from 4 lanes are merged using MergeSamfiles from picard (https://github.com/broadinstitute/picard/releases/download/2.22.3/picard.jar)</p><p>&nbsp;</p><p><strong>Below is the shell script for executing these steps starting from trimming </strong></p><p><strong>&nbsp;</strong></p><p><em>#Note: Variable “name” indicates the folder names (PR1643-xxx) corresponding to each of the samples. Each sample has 4 lanes (L001,L002,L003,L004) giving rise to 4 fastq files. This script is executed from the main folder that has all the library sub-folders. Within the main folder is a folder for each sample with the folder names (PR1643-xxx). Within each of these sample folders are four folders, one for each lane, labeled L001-4.&nbsp;Prior to running the following shell script, it is expected that one unzipped fastq file corresponding to the appropriate file and lane resides in each folder. The following script will write the output of umi_homopolyer.py and STAR into the respective lane folders.&nbsp;The output of the MergeSamFiles will write the combined sam file to top level of the sample folder.</em></p><p>&nbsp;</p><p><em>#!/bin/bash</em></p><p><em>for name in PR1643*; do</em></p><p><em>echo $name</em></p><p><em>&nbsp;</em></p><p><strong><u>#1. run python code to trim polyA tail and g-overhang</u></strong></p><p><em>python umi_homopolymer.py ./$name/L001/*.fastq ./$name/L001/$name\\_L001.fastq</em></p><p><em>python umi_homopolymer.py ./$name/L002/*.fastq ./$name/L002/$name\\_L002.fastq</em></p><p><em>python umi_homopolymer.py ./$name/L003/*.fastq ./$name/L003/$name\\_L003.fastq</em></p><p><em>python umi_homopolymer.py ./$name/L004/*.fastq ./$name/L004/$name\\_L004.fastq</em></p><p><em>&nbsp;</em></p><p><strong><u>#2. Run STAR to align the reads to reference genome</u></strong></p><p><em>STAR --runThreadN 60 --quantMode GeneCounts --genomeDir Pig_genome/star_index --readFilesIn&nbsp;./$name/L001/${name}_L001.fastq&nbsp;&nbsp;--outFileNamePrefix ./$name/L001/${name}_L001_star&nbsp;--outFilterMultimapNmax 1 --outFilterScoreMinOverLread 0.1 --outFilterMatchNminOverLread 0.1 --outFilterMatchNmin 0 --outFilterMismatchNmax 999 -clip3pAdapterMMP 0.2 -clip3pAdapterSeq AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA --twopassMode Basic</em></p><p><em>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</em></p><p><em>STAR --runThreadN 60 --quantMode GeneCounts --genomeDir Pig_genome/star_index --readFilesIn&nbsp;./$name/L002/${name}_L002.fastq&nbsp;&nbsp;--outFileNamePrefix ./$name/L002/${name}_L002_star&nbsp;--outFilterMultimapNmax 1 --outFilterScoreMinOverLread 0.1 --outFilterMatchNminOverLread 0.1 --outFilterMatchNmin 0 --outFilterMismatchNmax 999 -clip3pAdapterMMP 0.2 -clip3pAdapterSeq AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA --twopassMode Basic</em></p><p><em>&nbsp;</em></p><p><em>STAR --runThreadN 60 --quantMode GeneCounts --genomeDir Pig_genome/star_index --readFilesIn&nbsp;./$name/L003/${name}_L003.fastq&nbsp;&nbsp;--outFileNamePrefix ./$name/L003/${name}_L003_star&nbsp;--outFilterMultimapNmax 1 --outFilterScoreMinOverLread 0.1 --outFilterMatchNminOverLread 0.1 --outFilterMatchNmin 0 --outFilterMismatchNmax 999 -clip3pAdapterMMP 0.2 -clip3pAdapterSeq AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA --twopassMode Basic</em></p><p><em>&nbsp;</em></p><p><em>STAR --runThreadN 60 --quantMode GeneCounts --genomeDir Pig_genome/star_index --readFilesIn&nbsp;./$name/L004/${name}_L004.fastq&nbsp;&nbsp;--outFileNamePrefix ./$name/L004/${name}_L004_star&nbsp;--outFilterMultimapNmax 1 --outFilterScoreMinOverLread 0.1 --outFilterMatchNminOverLread 0.1 --outFilterMatchNmin 0 --outFilterMismatchNmax 999 -clip3pAdapterMMP 0.2 -clip3pAdapterSeq AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA --twopassMode Basic</em></p><p><em>&nbsp;</em></p><p><strong><u>#3. Merge sam files from 4 lanes into one file</u></strong></p><p><em>java -jar ~/Downloads/picard-2.18.14.jar MergeSamFiles</em></p><p><em>I=./$name/L001/$name\\_L001_star-Aligned.out.sam</em></p><p><em>I=./$name/L002/$name\\_L002_star-Aligned.out.sam</em></p><p><em>I=./$name/L003/$name\\_L003_star-Aligned.out.sam</em></p><p><em>I=./$name/L004/$name\\_L004_star-Aligned.out.sam</em></p><p><em>O=PR1643/STAR/$name\\.sam</em></p><p><em>&nbsp;</em></p><p><em>done</em></p><p>&nbsp;</p><p>&nbsp;</p><p><strong>&nbsp;Feature Count</strong></p><p>&nbsp;</p><p>Feature count algorithm, Subread R (featureCounts) package (Liao et al 2013) was used to count genomic features genes and exons per transcript. A digital gene expression matrix was created from this data.</p><p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Download the R package SUBREAD, for Read summarization</p><p>·&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use the same reference annotation file used for read aligning</p><p><strong>&nbsp;</strong></p><p><strong>&nbsp;</strong></p><p>Below is the R script for counting the reads to their genomic features - genes<strong>. </strong>The folder contains the merged sam files.</p><p><br></p><p>&nbsp;</p><p><strong><u>#1. Load the necessary package</u></strong></p><p><em>library(Rsubread)</em></p><p><br></p><p><em>#Import the sam files to a folder and Set the RStudio working directory to the location of the&nbsp;folder</em></p><p><em>extension &lt;- \"sam\"</em></p><p><em>fileNames &lt;- Sys.glob(paste(\"*.\", extension, sep=\"\"))</em></p><p><em>savefolder&nbsp;&lt;- \"PR1643/FeatureCount\"</em></p><p><em>&nbsp;</em></p><p><strong><u>#2. Retrieve the genomic features - gene and exon</u></strong></p><p><em>for (fileName in fileNames)</em></p><p><em>{</em></p><p><em>##for genes</em></p><p><em>gene.result &lt;- featureCounts(file=sprintf(fileName),annot.ext=</em></p><p><em>\"Pig_genome/Sus_scrofa.Sscrofa11.1.95_clean.gtf\",isGTFAnnotationFile=TRUE, GTF.featureType = \"gene\",readExtension3=200, ignoreDup = TRUE, isPairedEnd = FALSE,allowMultiOverlap = TRUE, nthreads = 20 )</em></p><p><br></p><p><em>##for exons</em></p><p><em>exon.result &lt;- featureCounts(file=sprintf(fileName),annot.ext= “Pig_genome/Sus_scrofa.Sscrofa11.1.95_clean.gtf\",isGTFAnnotationFile=TRUE, GTF.featureType = \"exon\",readExtension3=200, ignoreDup = TRUE, isPairedEnd = FALSE,allowMultiOverlap = TRUE, nthreads = 20 )</em></p><p><em>&nbsp;</em></p><p><strong><u>#3. Export the gene and exon count matrices</u></strong></p><p><em>write.table(x=data.frame(gene.result$annotation,gene.result$counts), file = sprintf(\"%s/%s-gene-counts.txt\",savefolder,fileName), quote=FALSE, sep=\"\\t\")</em></p><p><em>write.table(x=data.frame(exon.result$annotation,exon.result$counts), file = sprintf(\"%s/%s-exon-counts.txt\",savefolder,fileName), quote=FALSE, sep=\"\\t\")</em></p><p><em>}</em></p><p>&nbsp;</p><p><strong>&nbsp;</strong></p><p><strong><u>2. Downstream Analysis</u></strong></p><p><strong>&nbsp;</strong></p><p>The gene matrix is used for downstream analysis. </p><p><br></p><p><strong>1. Annotation: </strong>We annotated the genes with gene symbols. The missing gene symbols were substituted by ensemble/wiki gene names.<strong> </strong></p><p><br></p><p><strong>2. Batch Correction:</strong> Multiple batch correction algorithm ComBat-seq (Zhang et al 2020) was used to account for technical variability arising from batch effect. </p><p><strong>3. Filtering:</strong> Quality of the final matrix is ensured by filtering samples based on the number of dropouts and abundance threshold. Out of 142 samples, 52 Samples with non-zero gene counts &lt;6000 were considered as outliers. Additionally, 10800 genes that are present in very low quantities (&lt;30 non-zero gene counts) were filtered out.</p><p><strong>4. Rlog transformation:</strong> A regularized log transformation was carried out using DESeq2 (Love et al. 2014). </p><p><strong>5. Normalization:</strong> We normalized the data using a quantile regression method SCnorm (Bacher et al. 2017).</p><p><strong><u>#1. Load necessary packages:</u></strong></p><p><em>library(tidyr)</em></p><p><em>library(dplyr)</em></p><p><em>library(reshape2)</em></p><p><em>library(biomaRt)</em></p><p><em>library(DESeq2)</em></p><p><em>library(Rtsne)</em></p><p><em>library(ggplot2)</em></p><p><em>library(cluster)</em></p><p><em>library(gtools)</em></p><p><em>library(pheatmap)</em></p><p><em>library(pcaMethods)</em></p><p><em>library(rgl)</em></p><p><em>&nbsp;library(limma)</em></p><p><em>library(sva)</em></p><p><em>library(edgeR)</em></p><p><em>library(SCnorm)</em></p><p><em>library(sva)</em></p><p><em>&nbsp;</em></p><p><strong><u>#2. Download functions from https://github.com/zhangyuqing/ComBat-seq</u></strong></p><p><em>&nbsp;</em></p><p><em>source (\"help_combat_seq.R\")</em></p><p><em>source (\"ComBat_seq.R\")</em></p><p><em>&nbsp;</em></p><p><em>&nbsp;#Import the gene counts file and Set the RStudio working directory to the location of the&nbsp;#gene&nbsp;&nbsp;</em></p><p><em>&nbsp;count matrix.</em></p><p><strong><u>&nbsp;</u></strong></p><p><strong><u>#3. Conversion of gene IDs and annotation</u></strong></p><p><em>&nbsp;</em></p><p><em>raw &lt;- read.table(\"PR1643-genes-counts.txt\",sep=\"\\t\", header = T, row.names = 1)</em></p><p><em>sums &lt;- rowSums(raw)</em></p><p><em>raw &lt;- raw[-which(sums==0),]</em></p><p><em>&nbsp;</em></p><p><em>#Using ensembl database, retrieve gene names, description, wiki gene names and</em></p><p><em>#description</em></p><p><em>&nbsp;</em></p><p><em>genes &lt;- rownames(raw)</em></p><p><em>ensembl &lt;- useMart(\"ensembl\")</em></p><p><em>ensembl &lt;- useMart(\"ensembl\",dataset=\"sscrofa_gene_ensembl\", host=\"uswest.ensembl.org\")</em></p><p><em>G_list &lt;- getBM(filters= \"ensembl_gene_id\", attributes= c(\"ensembl_gene_id\",\"external_gene_name\",\"description\",\"wikigene_description\",\"wikigene_name\"),values=genes,mart= ensembl)</em></p><p><em>&nbsp;</em></p><p><em>&nbsp;</em></p><p><em>#Remove duplicate gene rows and substitute the absent gene names (NAs) with #corresponding ensemble IDs/wiki names</em></p><p><em>&nbsp;</em></p><p><em>raw2 &lt;- raw; raw2$ensembl_gene_id &lt;- rownames(raw2)</em></p><p><em>new.list &lt;- G_list[-which(duplicated(G_list$ensembl_gene_id)),]</em></p><p><em>full.list &lt;- right_join(new.list,raw2)</em></p><p><em>&nbsp;</em></p><p><em>gene.names &lt;- make.names(full.list$ensembl_gene_id, unique = T)</em></p><p><br></p><p><em>##gene names where the external gene name and wikigene name are the same</em></p><p><em>gene.names[which(full.list$external_gene_name != \"\" &amp; full.list$wikigene_name != \"\" &amp; full.list$external_gene_name == full.list$wikigene_name)] &lt;- full.list$external_gene_name[which(full.list$external_gene_name != \"\" &amp; full.list$wikigene_name != \"\" &amp; full.list$external_gene_name == full.list$wikigene_name)]</em></p><p><em>&nbsp;</em></p><p><em>##gene names where no external gene name was available but wikigene name is, set #to wikigene name</em></p><p><em>gene.names[which(full.list$external_gene_name == \"\" &amp; full.list$wikigene_name != \"\")] &lt;- full.list$wikigene_name[which(full.list$external_gene_name == \"\" &amp; full.list$wikigene_name != \"\")]</em></p><p><em>&nbsp;</em></p><p><em>##gene names where external gene name was available but wikigene name is not, set #to external gene name</em></p><p><em>gene.names[which(full.list$external_gene_name != \"\" &amp; full.list$wikigene_name == \"\")] &lt;- full.list$external_gene_name[which(full.list$external_gene_name != \"\" &amp; full.list$wikigene_name == \"\")]</em></p><p><em>&nbsp;</em></p><p><em>##when external gene name and wikigene name are both available, but not the same, #combine both, separated by a “_” for easier downstream reference</em></p><p><em>gene.names[which(full.list$external_gene_name != \"\" &amp; full.list$wikigene_name != \"\" &amp; full.list$external_gene_name != full.list$wikigene_name)] &lt;- paste0(full.list$external_gene_name[</em></p><p><em>&nbsp;which(full.list$external_gene_name != \"\" &amp; full.list$wikigene_name != \"\" &amp; full.list$external_gene_name != full.list$wikigene_name)], \"_\" ,</em></p><p><em>full.list$wikigene_name[which(full.list$external_gene_name != \"\" &amp; full.list$wikigene_name != \"\" &amp; full.list$external_gene_name != full.list$wikigene_name)])</em></p><p><em>&nbsp;</em></p><p><em>full.list$gene_name &lt;- make.names(gene.names, unique=T)</em></p><p><em>&nbsp;</em></p><p><em>##change order </em></p><p><em>full.list &lt;- full.list[,c(1,ncol(full.list), 2:(ncol(full.list)-1))]</em></p><p><br></p><p><em>##set blanks to NA </em></p><p><em>full.list2 &lt;- full.list; full.list2[which(full.list==\"\", arr.ind = T)] &lt;- NA</em></p><p><em>&nbsp;</em></p><p><em>##substitute commas for a period in the description to enable properly writing output as csv file</em></p><p><em>full.list2$description &lt;- gsub(\",\",\"\\\\.\", full.list2$description); full.list2$wikigene_description &lt;- gsub(\",\",\"\\\\.\", full.list2$wikigene_description)</em></p><p><em>&nbsp;</em></p><p><em>#Save the corresponding gene annotation csv file</em></p><p><em>&nbsp;</em></p><p><em>write.csv(full.list2[,1:6], \"PR1643_RNAseq_IDs_Genes_Description.csv\", row.names=F, quote=F)</em></p><p><em>&nbsp;</em></p><p><em>full_dataset &lt;- as.matrix(full.list2[,7:ncol(full.list2)]); rownames(full_dataset) &lt;- full.list2$ensembl_gene_id</em></p><p><em>rownames(full_dataset) &lt;- full.list2$gene_name</em></p><p><em>&nbsp;</em></p><p><em>&nbsp;</em></p><p><em>#Save the gene count matrix with the gene IDs as row names</em></p><p><em>&nbsp;write.table(full_dataset,\"PR1643_raw_RNAseqData_gene_names.txt\",sep=\"\\t\",quote=F, col.names = NA)</em></p><p><em>&nbsp;</em></p><p><em>&nbsp;</em></p><p><strong><u>#4. Batch correction for the two sets of runs</u></strong></p><p><em>&nbsp;</em></p><p><em>#Remove genes with total expression count = NULL</em></p><p><em>&nbsp;</em></p><p><em>full &lt;- full_dataset[which(rowSums(full_dataset)&gt;0),]</em></p><p><em>&nbsp;</em></p><p><em>#Separate the batches of 47 and 95 samples</em></p><p><em>&nbsp;batch47 &lt;- full[,1:47]</em></p><p><em>batch95 &lt;- full[,48:142]</em></p><p><br></p><p><em>col.data &lt;- data.frame(batch=c(rep(\"Batch47\",47), rep(\"Batch95\",95)));</em></p><p><em>rownames(col.data) &lt;- colnames(full)</em></p><p><em>annot_samp &lt;- col.data</em></p><p><em>annot_cols &lt;- NA</em></p><p><em>&nbsp;</em></p><p><em>counts &lt;- as.matrix(full)</em></p><p><em>batch &lt;- as.factor(c(rep(\"b47\", 47), rep(\"b95\", 95)))</em></p><p><em>&nbsp;</em></p><p><em>#Make sure that the parameters for the function ComBat_seq are individually specified</em></p><p><em>&nbsp;group &lt;- NULL</em></p><p><em>full_mod &lt;- FALSE</em></p><p><em>covar_mod &lt;- NULL</em></p><p><em>shrink &lt;- FALSE</em></p><p><em>shrink.disp &lt;- NULL</em></p><p><em>gene.subset.n &lt;- NULL</em></p><p><em>&nbsp;</em></p><p><em>adjusted&lt;- ComBat_seq(counts, batch=batch)</em></p><p><em>&nbsp;</em></p><p><em>#Save the batch adjusted data into a new file</em></p><p><em>&nbsp;</em></p><p><em>write.table(adjusted,\"FullSet_142_adjusted.txt\", sep=\"\\t\", quote=F)</em></p><p><em>&nbsp;</em></p><p><strong><u>&nbsp;#",
    {
        "title": "5.",
        "body": "Filtering Data</u></strong></p><p><em> </em></p><p><em>PR1643.142.adjusted <- adjusted</em></p><p><em> </em></p><p><em>#Assess genes – samples with non-zero counts</em></p><p><em> </em></p><p><em>samples.with.counts <- apply(PR1643.142.adjusted, 1, function(x)(sum(x!=0)))</em></p><p><em>tot.counts <- apply(PR1643.142.adjusted,1, function(x)(sum(x)))</em></p><p><em>average <- apply(PR1643.142.adjusted,1, function(x)(mean(x)))</em></p><p><em> </em></p><p><em>stats <- data.frame(samples.with.counts,tot.counts,average)</em></p><p><em>ggplot(stats, aes(samples.with.counts)) + geom_histogram() + scale_x_log10() + scale_y_log10()</em></p><p><em>ggplot(stats, aes(1:142,samples.with.counts)) + geom_bar() + scale_x_log10() + scale_y_log10()</em></p><p><em> </em></p><p><em>#Assess samples</em></p><p><em> </em></p><p><em>samples.with.counts <- apply(PR1643.142.adjusted, 2, function(x)(sum(x!=0)))</em></p><p><em>tot.counts <- apply(PR1643.142.adjusted,2, function(x)(sum(x)))</em></p><p><em>average <- apply(PR1643.142.adjusted,2, function(x)(mean(x)))</em></p><p><em> </em></p><p><em>stats <- data.frame(samples.with.counts,tot.counts,average)</em></p><p><em>ggplot(stats, aes(samples.with.counts)) + geom_histogram() #+ scale_x_log10() + scale_y_log10()</em></p><p><em>ggplot(stats, aes(tot.counts)) + geom_histogram() + scale_x_log10() + scale_y_log10()</em></p><p><em>ggplot(stats, aes(average)) + geom_histogram() + scale_x_log10() + scale_y_log10()</em></p><p><em> </em></p><p><em>#First level filtering</em></p><p><em> </em></p><p><em>PR1643.142.adjusted.filt <- PR1643.142.adjusted[,-which(samples.with.counts < 3000 & tot.counts < 100000)]</em></p><p><em> </em></p><p><em>#Save the file –after first filtering -132 samples</em></p><p><em> </em></p><p><em>write.table(PR1643.142.adjusted.filt, \"PR1643-132-adjusted.txt\", sep=\"\\t\", quote=F)</em></p><p><em> raw <- PR1643.142.adjusted.filt</em></p><p><em> </em></p><p><em> </em></p><p><em>#Remove genes with max rld value of 0 or less</em></p><p><em> </em></p><p><em>raw2 <- t(apply(raw+1,1,function(x)(log2(x))))</em></p><p><em>max.genes <- apply(raw2,1,max)</em></p><p><em>max.samples <- apply(raw2,2,max)</em></p><p><em> </em></p><p><em>samples.with.counts.filt <- apply(raw, 2, function(x)(sum(x!=0)))</em></p><p><em>genes.with.counts.filt <- apply(raw, 1, function(x)(sum(x!=0)))</em></p><p><em> </em></p><p><em>mat.ordered2 <- raw2[rev(order(genes.with.counts.filt)), rev(order(samples.with.counts.filt))]</em></p><p><em>mat.ordered3 <- mat.ordered2; mat.ordered3[which(mat.ordered2==0)] <- NA         ##still log2</em></p><p><em>raw.ordered2 <- raw[rev(order(genes.with.counts.filt)), rev(order(samples.with.counts.filt))]</em></p><p><em> </em></p><p><em>#Filtering samples with non-zero gene counts <6000 and genes <30</em></p><p><em> </em></p><p><em>filtered <- mat.ordered2[1:15000,1:90]</em></p><p><em>filtered.raw <- raw.ordered2[1:15000,1:90]</em></p><p><em>write.table(filtered.raw, \"PR1643_adjusted_raw_90samps_15kgenes.txt\", sep=\"\\t\", quote=F)</em></p><p><em> </em></p><p><strong><u> </u></strong></p><p><strong><u> </u></strong></p><p><strong><u>#6. Regularized log normalization - DESeq</u></strong></p><p><em> </em></p><p><em>ragp.raw <- filtered.raw</em></p><p><em> </em></p><p><em>#Regularized log transformation : rlog takes long to run</em></p><p><em>ragp.rlog <- rlog(ragp.raw, fitType = \"local\", blind = T);</em></p><p><em> rownames(ragp.rlog) <- rownames(ragp.raw)</em></p><p><br></p><p><em> #Median centering</em></p><p><em>ragp.rlog.med <- t(apply(ragp.rlog,1,function(x)(x-median(x))))</em></p><p><em> </em></p><p><em>#Extract high expression genes for visualization</em></p><p><em>count.means <- apply(ragp.raw,1,mean)</em></p><p><em>highgenes <- rownames(ragp.raw)[which(count.means>10)]</em></p><p><em> </em></p><p><em>#Using total counts</em></p><p><em>top200 <- rev(sort(rowSums(ragp.raw)))[1:200]</em></p><p><em>top2000 <- rev(sort(rowSums(ragp.raw)))[1:2000]</em></p><p><em> </em></p><p><em> </em></p><p><em> </em></p><p><strong><u>#7. Normalization- SCnorm</u></strong></p><p><em> </em></p><p><em>#Input is DESeq rlog matrix (90 samples, 15000 genes)</em></p><p><em>mySCData <- SingleCellExperiment::SingleCellExperiment(assays = list('counts' = ragp.rlog))</em></p><p><em>Conditions <- as.factor(annot_samp$batch)</em></p><p><em> </em></p><p><em>countDeptEst <- plotCountDepth(Data = mySCData, Conditions = Conditions,FilterCellProportion = .1, NCores=4)</em></p><p><em>str(countDeptEst)</em></p><p><em>head(countDeptEst[[1]])</em></p><p><em> </em></p><p><em>mySCData = SingleCellExperiment::counts(mySCData)</em></p><p><em> </em></p><p><em>#SCnormalization </em></p><p><em>DataNorm <- SCnorm(Data = mySCData,Conditions = Conditions,PrintProgressPlots = TRUE,FilterCellNum = 10, NCores=4, reportSF = TRUE)</em></p><p><em> </em></p><p><em> DataNorm</em></p><p><em> NormalizedData.rlog <- SingleCellExperiment::normcounts(DataNorm)</em></p><p><em> row.names(NormalizedData.rlog) <- row.names(ragp.rlog)</em></p><p><em> NormalizedData.rlog[1:5,1:5]</em></p><p><em> </em></p><p><em>#Save the normalized count data into a new file</em></p><p><em>write.table(NormalizedData.rlog,\"PR1643-normalized_90samples_15kgenes.txt\", sep=\"\\t\", quote=F, col.names = NA, row.names = T)</em></p><p> </p>"
    }
]